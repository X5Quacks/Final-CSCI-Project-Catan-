//Update(Aaron, 12/3/2025)
import java.util.*;
import java.io.*;

/*
 * play game
 */
public class CatanDriver{
  
  //RANDOM
  private static final Random random = new Random();
  
  //GAMEBOARD
  private static Board board;
  
  //PLAYERS
  private static Player one;
  private static Player two;
  
  public CatanDriver() throws IOException{
    this.board = new Board();
    this.one = new Player(getBoard().getNode("A"));
    this.two = new Player(getBoard().getNode("D"));
  }
  
  //main plays the game
  public static void main(String[] args) throws IOException{
    
    //used AI to make some fancy print statements
    CatanDriver cd = new CatanDriver();
    getBoard().getRoads().forEach((key, value) -> System.out.println("Key: " + key + ", Value: " + value));
    getBoard().getResources().forEach((key, value) -> System.out.println("Key: " + key + ", Value: " + value));
    
    int current = 1; //current player
    
    //TODO testing purposes only
    getPlayer(1).modifyResource("wood", 5);
    getPlayer(1).modifyResource("wheat", 5);
    getPlayer(1).modifyResource("clay", 5);
    getPlayer(1).modifyResource("stone", 5);
    getPlayer(1).modifyResource("sheep", 5);
    getPlayer(2).modifyResource("wood", 5);
    getPlayer(2).modifyResource("wheat", 5);
    getPlayer(2).modifyResource("clay", 5);
    getPlayer(2).modifyResource("stone", 5);
    getPlayer(2).modifyResource("sheep", 5);
    
    cd.generateResources(1);
    while(cd.getScore(1) < 5 && cd.getScore(2) < 5){
      int endTurn = userTurnSelection(current);
      if(endTurn == 5){
        if(current==1){current++;}
        else{current--;}
        cd.generateResources(current);
      }
      System.out.println(cd.getScore(current));
      cd.getPlayer(current).score++; //TODO remove before final game
    }
  }
  
  /*
   * return the Board
   * @return Board as the Catan Board
   */
  public static Board getBoard(){
    return board;
  }
  
  /*
   * get a Player's resources/current location
   * @param selection as int as which Player to get
   * @return Player as the selected Player
   */
  public static Player getPlayer(int selection){
    if(selection==1){
      return one;}
    else{
     return two;}
  }
  
  /*
   * keep the Player making inputs until they choose a valid option
   * @param maxRange as int as the max value that has an option
   * @param choices as String as the list of options for the Player
   * @param Scanner as Player input
   * @return int as the Player's choice
   */
  public static int scanCheck(int maxRange, String choices, Scanner scanner){
    boolean check = true;
    int userNum = 0;
    while(check){
      System.out.print(choices);
      String input = scanner.next();
      if (Character.isDigit(input.charAt(0)) && input.length() < 2) {
        userNum = Integer.parseInt(input);
        if(userNum > 0 && userNum < maxRange){
          check = false;
          break;}}
      if(check){
        System.out.println("Enter a valid number"); }}
    return userNum;
  }
  
  /*
   * let the player choose an option for their turn
   * (1) Move: move the player's piece to an adjacent location
   * (2) Build: build a road, settlement, or city
   * (3) Check Nearest Settlement: check how many moves the nearest settlement is away that you control
   * (4) Trade: if you are at a settlement you control, swap resources for other resources
   * (5) End Turn: end your turn, roll the resource dice, and go to the next player
   * @param current as int as the current Player
   * @return int as which option was chosen (if 5 it will end the turn)
   */
   public static int userTurnSelection(int current){
    Scanner scanner = new Scanner(System.in);
    boolean check = true;
    int userNum = scanCheck(6, "\n1) Move\n2) Build\n3) Check nearest settlement\n4) Trade\n5) End Turn\n: ", scanner);
    
    switch (userNum) {
      case 1:
        
        break;
      case 2:
        build(scanner, current);
        break;
      case 3:
        
        break;
      case 4:
        
        break;
      case 5:
        System.out.println("Ending player " + current + "'s turn.");
        break;
      default:
        break;
    }
    return userNum;
  }
   
  /*
   * rolls 2 dice
   * @return int as the total of the 2 dice added together
   */
  public static int diceRoll(){ 
    int dice1 = random.nextInt(6) + 1;
    int dice2 = random.nextInt(6) + 1;
    return dice1 + dice2;
  }
  
  /*
   * generate the resources for the start of the turn
   * @param current as int as the current Player
   */
  public void generateResources(int current){
    int dice = diceRoll();
    System.out.println("dice: " + dice);
    if(dice == 7){/*robber*/
      Set<Node> nodes = getBoard().getRoads().keySet();
      List<Node> myList = new ArrayList<Node>();
      Iterator<Node> iterator = nodes.iterator();
      while (iterator.hasNext()) {
        Node node = iterator.next();
        if(node.getPlayerControl() != 0 && node.getPlayerControl() != current){ 
          myList.add(node);
        }
      }
      Node robbed = myList.get(random.nextInt(myList.size())); //select a random opponents Settlement or City
      List<Hexagon> selection = getBoard().getResources().get(robbed);
      Hexagon newRobber = selection.get(random.nextInt(selection.size())); //select a random Hexagon on that Node
      newRobber.setRobberStatus(true); //add the robber
      List<String> steal = getPlayer(robbed.getPlayerControl()).getAvailableResources(); //get the opponents resources
      String stolen = steal.get(random.nextInt(steal.size())); //steal a random resource from opponent
      getPlayer(current).modifyResource(stolen, 1); //add to you
      getPlayer(robbed.getPlayerControl()).modifyResource(stolen, -1); //take from your opponent
      System.out.println("Robber placed on " + newRobber);
      //ToDo will not remove the old robber not sure if remove old robber or have Player method to attack robbers
    }
    else{ //generate resources
      Map<Node, List<Hexagon>> resources = getBoard().getResources();
      for(Node node : resources.keySet()){
        String structure = node.getStructure();
        if(!structure.equals("")){
          for(Hexagon hex : resources.get(node)){
            if(hex.getResourceNumber() == dice && !(hex.getRobberStatus())){
              
              Player p = getPlayer(node.getPlayerControl());
              String resource = hex.getResourceType();
              
              switch (structure) {
                case "Settlement":
                  System.out.println(node + " generated 1 " + resource);
                  p.modifyResource(resource, 1);
                  break;
                case "City":
                  System.out.println(node + " generated 2 " + resource);
                  p.modifyResource(resource, 2);
                  break;
                default:
                  break;}}}}}}}
  
  public static void move(){
    Player p = getPlayer(current);
    List<Edge> roads = getBoard().getAdjacents(p.getCurrent());
    for(int i = 0; i<roads.size(); i++){
      if(roads.get(i).getPlayerRoad() == 0){roads.remove(i);i--;}
      else{System.out.println(roads.get(i));}
    }
    if(roads.size() == 0){
      System.out.println("There are no roads");
    }
    else{
      int userNum = scanCheck(roads.size()+1, "Choose a road to move along\n: ", scanner);
      p.setCurrent(roads.get(userNum-1).getNode());
    }
  }
  
  /*
   * allow the player to build an object
   * @param Scanner as player input
   * @param current as int as the current Player
   */
  public static void build(Scanner scanner, int current){
    int userNum = scanCheck(4, "What do you want to build?\n1) Road\n2) Settlement\n3) City\n: ", scanner);

    Player p = getPlayer(current);
    switch (userNum) {
      case 1: // build Road
        if(p.getWood()<1 || p.getClay()<1){System.out.println("Not enough resources");}
        else{
          p.modifyResource("wood", -1);
          p.modifyResource("clay", -1);
          List<Edge> roads = getBoard().getAdjacents(p.getCurrent());
          for(int i = 0; i<roads.size(); i++){
            if(roads.get(i).getPlayerRoad() != 0){roads.remove(i);i--;}
            else{System.out.println(roads.get(i));}
          }
          userNum = scanCheck(roads.size()+1, "Choose a road to build\n: ", scanner);
          roads.get(userNum-1).setPlayerRoad(current);
        }
        break;
      case 2: // build Settlement
        if(p.getCurrent().getStructure().equals("")){
           if(p.getWood()<1 || p.getClay()<1 || p.getSheep()<1 || p.getWheat()<1){System.out.println("Not enough resources");}
           else{
             p.modifyResource("wood", -1);
             p.modifyResource("clay", -1);
             p.modifyResource("sheep", -1);
             p.modifyResource("wheat", -1);
             p.getCurrent().setStructure("Settlement");
             p.getCurrent().setPlayerControl(current);
             p.score++;
           }}
        else{System.out.println("There's already a structure here");}
        break;
      case 3: // build City
        if(p.getCurrent().getStructure().equals("Settlement")){
           if(p.getStone()<3 || p.getWheat()<2){System.out.println("Not enough resources");}
           else{
             p.modifyResource("stone", -3);
             p.modifyResource("wheat", -2);
             p.getCurrent().setStructure("City");
             p.score++;
           }}
        else{System.out.println("You do not have a Settlement here");}
        break;
      default:
        break;
    }}
  
  public static void checkNearestSettlement(){ //ToDo
    
  }
  
  public static void Trade(){ //ToDo
    
  }
  
  /*
   * get the score of the player
   * @param the score of the player youre checking
   * @return int as the score of the player
   */
  public int getScore(int player){
    return getPlayer(player).getScore() + isLongestRoad(player);
  }
  
  /*
   * does this player have the Longest Road
   * @param player as int as the player the game is checking for LongestRoad
   * @return int as 2 if yes or 0 if no
   */
  public int isLongestRoad(int player){
      Map<Node, Double> dist = new HashMap<Node, Double>(); //store paths

      for(Node v : getBoard().getRoads().keySet()){ //fill Map with NEGATIVE INFINITY to start
        dist.put(v, Double.NEGATIVE_INFINITY);
      }
      dist.put(getPlayer(player).getCurrent(), 0.0); //put current position in the Map TODO yes thats not how it works
      PriorityQueue<Edge> pq = new PriorityQueue<Edge>(); 
      pq.add(new Edge(getPlayer(player).getCurrent(), 0.0));
      
      while(!pq.isEmpty()){ //reverse of Dijkstras
        Edge current = pq.poll();
        Node v = current.destination;
          for(Edge e : getBoard().getAdjacents(v)){
            double totalDist = dist.get(v) + e.weight;
            if(totalDist > dist.get(e.getNode()) && e.getPlayerRoad() == player){
              dist.put(e.getNode(), totalDist);
              pq.add(e);
            }
        }
      }
      
      Collection<Double> distances = dist.values();
      Double distance1 = Collections.max(distances); //convert the Map into a max distance and print them
      System.out.println(distances+"    "+distance1);
      
      if(player==1){player++;}
      else{player--;} //switch Player and clear
      dist.clear();
      
      for(Node v : getBoard().getRoads().keySet()){ //fill Map with NEGATIVE INFINITY again
        dist.put(v, Double.NEGATIVE_INFINITY);
      }
      dist.put(getPlayer(player).getCurrent(), 0.0); //put current position in the Map TODO yes thats not how it works
      pq = new PriorityQueue<Edge>();
      pq.add(new Edge(getPlayer(player).getCurrent(), 0.0));
      
      while(!pq.isEmpty()){ //reverse of Dijkstras
        Edge current = pq.poll();
        Node v = current.destination;
          for(Edge e : getBoard().getAdjacents(v)){
            double totalDist = dist.get(v) + e.weight;
            if(totalDist > dist.get(e.getNode()) && e.getPlayerRoad() == player){
              dist.put(e.getNode(), totalDist);
              pq.add(e);
            }
        }
      }
      
      distances = dist.values();
      Double distance2 = Collections.max(distances);
      System.out.println(distances+"    "+distance2);
      
      if(distance1>distance2){
         return 2;}
      else{
         return 0;}
      //return 0;
  }
}
