//Update(Aaron, 12/7/2025)
//added the README.md and cleaned up the print statements
import java.util.*;
import java.io.*;

/*
 * play game
 * please work
 */
public class CatanDriver{
  
  //RANDOM
  private static final Random random = new Random();
  
  //GAMEBOARD
  private static Board board;
  
  //PLAYERS
  private static Player one;
  private static Player two;
  
  public CatanDriver() throws IOException{
    this.board = new Board();
    this.one = new Player(getBoard().getNode("A"));
    this.two = new Player(getBoard().getNode("D"));
  }
  
  //main plays the game
  public static void main(String[] args) throws IOException{
    
    //used AI to make some fancy print statements
    CatanDriver cd = new CatanDriver();
    //getBoard().getRoads().forEach((key, value) -> System.out.println("Key: " + key + ", Value: " + value));
    //getBoard().getResources().forEach((key, value) -> System.out.println("Key: " + key + ", Value: " + value));
    
    int current = 1; //current player
    
    Node a = getBoard().getNode("A");  
    a.setPlayerControl(1); 
    a.setStructure("Settlement");
    Node d = getBoard().getNode("D");
    d.setPlayerControl(2);
    d.setStructure("Settlement");
    
    //TODO testing purposes only
    getPlayer(1).modifyResource("wood", 2);
    getPlayer(1).modifyResource("wheat", 2);
    getPlayer(1).modifyResource("clay", 2);
    getPlayer(1).modifyResource("stone", 2);
    getPlayer(1).modifyResource("sheep", 2);
    getPlayer(2).modifyResource("wood", 2);
    getPlayer(2).modifyResource("wheat", 2);
    getPlayer(2).modifyResource("clay", 2);
    getPlayer(2).modifyResource("stone", 2);
    getPlayer(2).modifyResource("sheep", 2);
    
    gui graphics = new gui();
  
  
    
    cd.generateResources(1);
    while(cd.getScore(1) < 10 && cd.getScore(2) < 10){
      System.out.println(cd.getPlayer(current).getAllResources());
      int endTurn = userTurnSelection(current);
      if(endTurn == 6){
        if(current==1){current++;}
        else{current--;}
        cd.generateResources(current);
        cd.getPlayer(current).score++; //TODO remove before final game
        System.out.println("\nPlayer 1's score:  " + cd.getScore(1) +"  Player 2's score:  " + cd.getScore(2));
      }
    }
  }
  
  /*
   * return the Board
   * @return Board as the Catan Board
   */
  public static Board getBoard(){
    return board;
  }
  
  /*
   * get a Player's resources/current location
   * @param selection as int as which Player to get
   * @return Player as the selected Player
   */
  public static Player getPlayer(int selection){
    if(selection==1){
      return one;}
    else{
     return two;}
  }
  
  /*
   * keep the Player making inputs until they choose a valid option
   * @param maxRange as int as the max value that has an option
   * @param choices as String as the list of options for the Player
   * @param Scanner as Player input
   * @return int as the Player's choice
   */
  public static int scanCheck(int maxRange, String choices, Scanner scanner){
    boolean check = true;
    int userNum = 0;
    while(check){
      System.out.print(choices);
      String input = scanner.next();
      if (Character.isDigit(input.charAt(0)) && input.length() < 2) {
        userNum = Integer.parseInt(input);
        if(userNum > 0 && userNum < maxRange){
          check = false;
          break;}}
      if(check){
        System.out.println("Enter a valid number"); }}
    return userNum;
  }
  
  /*
   * let the player choose an option for their turn
   * (1) Move: move the player's piece to an adjacent location
   * (2) Build: build a road, settlement, or city
   * (3) Check Nearest Settlement: check how many moves the nearest settlement is away that you control
   * (4) Trade: if you are at a settlement you control, swap resources for other resources
   * (5) Fight a Robber: if there is a Robber on a Hexagon adjacent to you, roll 2 dice. If you get 7+, defeat the Robber. Otherwise, lose a random resource.
   * (6) End Turn: end your turn, roll the resource dice, and go to the next player
   * @param current as int as the current Player
   * @return int as which option was chosen (if 5 it will end the turn)
   */
   public static int userTurnSelection(int current){
    Scanner scanner = new Scanner(System.in);
    boolean check = true;
    int userNum = scanCheck(7, "\n1) Move\n2) Build\n3) Check nearest settlement\n4) Trade\n5) Fight a Robber\n6) End Turn\n: ", scanner);
    System.out.println("\n");
    
    switch (userNum) {
      case 1:
        move(scanner,current);
        break;
      case 2:
        build(scanner, current);
        break;
      case 3:
        System.out.println(checkNearestSettlement(current));
        break;
      case 4:
        
        break;  
      case 5:
        fightRobber(current);
        break;
      case 6:
        System.out.println("Ending player " + current + "'s turn.");
        break;
      default:
        break;
    }
    return userNum;
  }
   
  /*
   * rolls 2 dice
   * @return int as the total of the 2 dice added together
   */
  public static int diceRoll(){ 
    int dice1 = random.nextInt(6) + 1;
    int dice2 = random.nextInt(6) + 1;
    return dice1 + dice2;
  }
  
  /*
   * generate the resources for the start of the turn
   * @param current as int as the current Player
   */
  public void generateResources(int current){
    int dice = diceRoll();
    System.out.print("a " + dice + " has been rolled. ");
    if(dice == 7){/*robber*/
      Set<Node> nodes = getBoard().getRoads().keySet();
      List<Node> myList = new ArrayList<Node>();
      Iterator<Node> iterator = nodes.iterator();
      while (iterator.hasNext()) {
        Node node = iterator.next();
        if(node.getPlayerControl() != 0 && node.getPlayerControl() != current){ 
          myList.add(node);
        }
      }
      Node robbed = myList.get(random.nextInt(myList.size())); //select a random opponents Settlement or City
      List<Hexagon> selection = getBoard().getResources().get(robbed);
      Hexagon newRobber = selection.get(random.nextInt(selection.size())); //select a random Hexagon on that Node
      newRobber.setRobberStatus(true); //add the robber
      List<String> steal = getPlayer(robbed.getPlayerControl()).getAvailableResources(); //get the opponents resources
      String stolen = steal.get(random.nextInt(steal.size())); //steal a random resource from opponent
      getPlayer(current).modifyResource(stolen, 1); //add to you
      getPlayer(robbed.getPlayerControl()).modifyResource(stolen, -1); //take from your opponent
      System.out.println("Robber placed on: " + newRobber);
    }
    else{ //generate resources
      System.out.println("Generating resources.");
      Map<Node, List<Hexagon>> resources = getBoard().getResources();
      for(Node node : resources.keySet()){
        String structure = node.getStructure();
        if(!structure.equals("")){
          for(Hexagon hex : resources.get(node)){
            if(hex.getResourceNumber() == dice && !(hex.getRobberStatus())){
              
              Player p = getPlayer(node.getPlayerControl());
              String resource = hex.getResourceType();
              
              switch (structure) {
                case "Settlement":
                  System.out.println(node + " generated 1 " + resource);
                  p.modifyResource(resource, 1);
                  break;
                case "City":
                  System.out.println(node + " generated 2 " + resource);
                  p.modifyResource(resource, 2);
                  break;
                default:
                  break;}}}}}}}
  
  /*
   * Updated 12/14/2025 - Aaron
   * allow the player to move their player piece
   * @param Scanner as player input
   * @param current as int as the current Player
   */
  public static void move(Scanner scanner, int current){
    Player p = getPlayer(current);
    List<Edge> roads = getBoard().getAdjacents(p.getCurrent());

    boolean roadExist = false;
    for(int i = 0; i<roads.size(); i++){
      if(roads.get(i).getPlayerRoad() != 0){
        System.out.println("#" + (i+1) + " - " + roads.get(i));
        roadExist = true;
      }
    }
    if(!roadExist){
      System.out.println("There are no roads connected to you.");
    }
    else{
      int userNum = scanCheck(roads.size()+1, "Choose a road to move along\n: ", scanner);
      p.setCurrent(roads.get(userNum-1).getNode());
    }
  }
  
  /*
   * Updated 12/14/2025 - Aaron
   * allow the player to build an object
   * @param Scanner as player input
   * @param current as int as the current Player
   */
  public static void build(Scanner scanner, int current){
    int buildNum = scanCheck(4, "What do you want to build?\n1) Road (costs 1 wood and 1 clay)\n2) Settlement (costs 1 wood, clay, sheep, and wheat)\n3) City (costs 2 wheat and 3 stone)\n: ", scanner);

    Player p = getPlayer(current);
    switch (buildNum) {
      case 1: // build Road
        if(p.getWood()<1 || p.getClay()<1){System.out.println("Not enough resources");}
        else{
          p.modifyResource("wood", -1);
          p.modifyResource("clay", -1);
          List<Edge> roads = getBoard().getAdjacents(p.getCurrent());
          for(int i = 0; i<roads.size(); i++){
            if(roads.get(i).getPlayerRoad() == 0){
              System.out.println("#" + (i+1) + " - " + roads.get(i));}
          }
          buildNum = scanCheck(roads.size()+1, "Choose a road to build\n: ", scanner);
          Edge road = roads.get(buildNum-1);
          road.setPlayerRoad(current); //builds the road from your direction
          road.setWeight(-1.0);
          
          List<Edge> opposites = getBoard().getAdjacents(road.getNode()); //builds the road from the other direction
          int indexOfOpposite = -1;
          for(int i = 0; i < opposites.size(); i++){
            if(opposites.get(i).getNode()==p.getCurrent()){
              indexOfOpposite = i;
            }
          }
          //System.out.println(indexOfOpposite); //index of which Edge this corresponds to
          opposites.get(indexOfOpposite).setPlayerRoad(current); 
          opposites.get(indexOfOpposite).setWeight(-1.0);

        }
        break;
      case 2: // build Settlement
        if(p.getCurrent().getStructure().equals("")){
           if(p.getWood()<1 || p.getClay()<1 || p.getSheep()<1 || p.getWheat()<1){System.out.println("Not enough resources");}
           else{
             p.modifyResource("wood", -1);
             p.modifyResource("clay", -1);
             p.modifyResource("sheep", -1);
             p.modifyResource("wheat", -1);
             p.getCurrent().setStructure("Settlement");
             p.getCurrent().setPlayerControl(current);
             p.score++;
           }}
        else{System.out.println("There's already a structure here");}
        break;
      case 3: // build City
        if(p.getCurrent().getStructure().equals("Settlement")){
           if(p.getStone()<3 || p.getWheat()<2){System.out.println("Not enough resources");}
           else{
             p.modifyResource("stone", -3);
             p.modifyResource("wheat", -2);
             p.getCurrent().setStructure("City");
             p.score++;
           }}
        else{System.out.println("You do not have a Settlement here");}
        break;
      default:
        break;
    }}
  
  public static Node checkNearestSettlement(int current){
    List<Node> order = new ArrayList<Node>();
    Set<Node> visited = new HashSet<Node>();
    Queue<Node> q = new LinkedList<Node>();
    Player player = getPlayer(current);
    q.add(player.getCurrent());
    boolean foundSettlement = true;
    Node visit = null;
    while(!q.isEmpty() && foundSettlement){
      
      visit = q.remove();
      
      if(!visited.contains(visit) && !visit.getStructure().equals("Settlement")){
        visited.add(visit);
        order.add(visit);
        
        for(Edge e : getBoard().getAdjacents(visit)) {
          if(!visited.contains(e.getNode())){
            q.add(e.getNode());
          }
        }
      }
      else{
        foundSettlement = false;
      }
    }
    return visit;
  }
  
  public static void Trade(){ //ToDo
    //eh, this one can be skipped
  }
  
  /*
   * roll dice to fight Robbers adjacent to the current Player's location
   * if the Player gets a 7+, they win and gain a resource. On a 6- they get robbed a resource
   * @param current as int as the current Player
   */
  public static void fightRobber(int current){
    Player player = getPlayer(current);
    List<Hexagon> selection = getBoard().getResources().get(player.getCurrent()); //get Hexagons adjacent to your Node
    for(Hexagon hex : selection){
      if(hex.getRobberStatus()){
        int attack = diceRoll();
        if(attack >= 7){
          hex.setRobberStatus(false);
          player.modifyResource(hex.getResourceType(), 1);
          System.out.println("You defeated the Robber and took 1 " + hex.getResourceType());
        }
        else{
          List<String> steal = player.getAvailableResources(); //get the player's resources
          String stolen = steal.get(random.nextInt(steal.size())); //steal a random resource
          player.modifyResource(stolen, -1); //lose the resource
          System.out.println("You lost against a Robber and lost 1 " + stolen);
        }}}}
  
  /*
   * get the score of the player
   * @param the score of the player youre checking
   * @return int as the score of the player
   */
  public int getScore(int player){
    return getPlayer(player).getScore() + isLongestRoad(player);
  }
  
  /*
   * does this player have the Longest Road
   * @param player as int as the player the game is checking for LongestRoad
   * @return int as 2 if yes or 0 if no
   */
  public int isLongestRoad(int player){
    Map<Node, Double> dist = new HashMap<Node, Double>(); //store paths

    for(Node v : getBoard().getRoads().keySet()){
      dist.put(v, Double.POSITIVE_INFINITY);
    }
    dist.put(getPlayer(player).getCurrent(), 0.0);
    PriorityQueue<Edge> pq = new PriorityQueue<Edge>();
    pq.add(new Edge(getPlayer(player).getCurrent(), 0.0));
    Set<Node> visited = new HashSet<Node>();
    
    while(!pq.isEmpty()){
      Edge current = pq.poll();
      Node v = current.getNode();
      if(current.weight <= dist.get(v) && !visited.contains(v)){
        visited.add(v);
        for(Edge e : getBoard().getAdjacents(v)){
          double totalDist = dist.get(v) + e.weight;
          if(totalDist < dist.get(e.getNode()) && e.getPlayerRoad() == player){
            dist.put(e.getNode(), totalDist);
            pq.add(new Edge(e.getNode(), totalDist));
          }
        }
      }
    }  

          
    Collection<Double> distances = dist.values();
    Double distance1 = Collections.min(distances); //convert the Map into a max distance and print them
    //System.out.println(distances+"    "+distance1);
    
    if(player==1){player++;}
    else{player--;} //switch Player and clear
    dist.clear();
    
    for(Node v : getBoard().getRoads().keySet()){
      dist.put(v, Double.POSITIVE_INFINITY);
    }
    dist.put(getPlayer(player).getCurrent(), 0.0);
    pq = new PriorityQueue<Edge>();
    pq.add(new Edge(getPlayer(player).getCurrent(), 0.0));
    visited = new HashSet<Node>();
    
     while(!pq.isEmpty()){
      Edge current = pq.poll();
      Node v = current.getNode();
      if(current.weight <= dist.get(v) && !visited.contains(v)){
        visited.add(v);
        for(Edge e : getBoard().getAdjacents(v)){
          double totalDist = dist.get(v) + e.weight;
          if(totalDist < dist.get(e.getNode()) && e.getPlayerRoad() == player){
            dist.put(e.getNode(), totalDist);
            pq.add(new Edge(e.getNode(), totalDist));
          }
        }
      }
    }   
          
    distances = dist.values();
    Double distance2 = Collections.min(distances); //convert the Map into a max distance and print them
    
    if(distance1<distance2){
      return 2;}
    else{
      return 0;}
  }
}
